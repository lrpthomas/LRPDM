#!/usr/bin/env ts-node

/**
 * Spatial Performance Audit Script
 * Generated by database-spatial-agent
 * 
 * This script analyzes spatial query performance and provides optimization recommendations
 */

import { db as knex } from '../config/database';
import fs from 'fs';
import path from 'path';

interface PerformanceMetric {
  metric: string;
  value: number | string;
  status: 'good' | 'warning' | 'critical';
  recommendation?: string;
}

interface IndexAnalysis {
  table: string;
  index: string;
  type: string;
  size: string;
  scans: number;
  tuplesRead: number;
  tuplesReturned: number;
  efficiency: number;
  recommendation: string;
}

interface QueryAnalysis {
  query: string;
  avgTime: number;
  calls: number;
  totalTime: number;
  rowsReturned: number;
  recommendation: string;
}

class SpatialPerformanceAuditor {
  private results: {
    metrics: PerformanceMetric[];
    indexes: IndexAnalysis[];
    queries: QueryAnalysis[];
    tableStats: any[];
    recommendations: string[];
  } = {
    metrics: [],
    indexes: [],
    queries: [],
    tableStats: [],
    recommendations: []
  };

  async runFullAudit(): Promise<void> {
    console.log('üîç Starting comprehensive spatial performance audit...\n');

    try {
      // Enable query timing (skip problematic settings)
      // await knex.raw('SET track_functions = all');
      // await knex.raw('SET log_statement_stats = on');

      await this.checkPostGISConfiguration();
      await this.analyzeSpatialIndexes();
      await this.analyzeTableStatistics();
      await this.analyzeSpatialQueries();
      await this.checkGeometryComplexity();
      await this.analyzeStorageUsage();
      await this.benchmarkCommonOperations();
      
      this.generateRecommendations();
      await this.generateReport();

    } catch (error) {
      console.error('‚ùå Audit failed:', error);
      throw error;
    }
  }

  private async checkPostGISConfiguration(): Promise<void> {
    console.log('üìã Checking PostGIS configuration...');

    // Check PostGIS version
    const version = await knex.raw('SELECT PostGIS_version()');
    this.results.metrics.push({
      metric: 'PostGIS Version',
      value: version.rows[0].postgis_version,
      status: 'good'
    });

    // Check shared_buffers
    const sharedBuffers = await knex.raw('SHOW shared_buffers');
    const bufferSize = sharedBuffers.rows[0].shared_buffers;
    this.results.metrics.push({
      metric: 'Shared Buffers',
      value: bufferSize,
      status: this.evaluateBufferSize(bufferSize),
      recommendation: this.evaluateBufferSize(bufferSize) !== 'good' ? 
        'Consider increasing shared_buffers to 25% of system RAM for better spatial query performance' : undefined
    });

    // Check work_mem
    const workMem = await knex.raw('SHOW work_mem');
    const workMemSize = workMem.rows[0].work_mem;
    this.results.metrics.push({
      metric: 'Work Memory',
      value: workMemSize,
      status: this.evaluateWorkMem(workMemSize),
      recommendation: this.evaluateWorkMem(workMemSize) !== 'good' ? 
        'Consider increasing work_mem for complex spatial operations' : undefined
    });

    // Check effective_cache_size
    const cacheSize = await knex.raw('SHOW effective_cache_size');
    this.results.metrics.push({
      metric: 'Effective Cache Size',
      value: cacheSize.rows[0].effective_cache_size,
      status: 'good'
    });

    // Check random_page_cost
    const randomCost = await knex.raw('SHOW random_page_cost');
    const cost = parseFloat(randomCost.rows[0].random_page_cost);
    this.results.metrics.push({
      metric: 'Random Page Cost',
      value: cost,
      status: cost > 2.0 ? 'warning' : 'good',
      recommendation: cost > 2.0 ? 
        'Consider lowering random_page_cost to 1.5-2.0 for SSD storage' : undefined
    });
  }

  private async analyzeSpatialIndexes(): Promise<void> {
    console.log('üìä Analyzing spatial indexes...');

    const indexQuery = `
      SELECT 
        schemaname,
        tablename,
        indexname,
        indexdef,
        pg_size_pretty(pg_relation_size(indexrelid)) as size,
        idx_scan,
        idx_tup_read,
        idx_tup_fetch,
        CASE 
          WHEN idx_tup_read > 0 THEN round((idx_tup_fetch::float / idx_tup_read) * 100, 2)
          ELSE 0 
        END as efficiency
      FROM pg_stat_user_indexes 
      JOIN pg_indexes ON pg_indexes.indexname = pg_stat_user_indexes.indexname
      WHERE indexdef LIKE '%gist%' OR indexdef LIKE '%gin%'
      ORDER BY pg_relation_size(indexrelid) DESC;
    `;

    const indexes = await knex.raw(indexQuery);

    for (const idx of indexes.rows) {
      const analysis: IndexAnalysis = {
        table: idx.tablename,
        index: idx.indexname,
        type: idx.indexdef.includes('gist') ? 'GIST' : 'GIN',
        size: idx.size,
        scans: idx.idx_scan || 0,
        tuplesRead: idx.idx_tup_read || 0,
        tuplesReturned: idx.idx_tup_fetch || 0,
        efficiency: idx.efficiency || 0,
        recommendation: this.getIndexRecommendation(idx)
      };

      this.results.indexes.push(analysis);
    }

    // Check for missing spatial indexes
    await this.checkMissingSpatialIndexes();
  }

  private async checkMissingSpatialIndexes(): Promise<void> {
    const geometryColumns = await knex.raw(`
      SELECT 
        f_table_name,
        f_geometry_column,
        coord_dimension,
        srid,
        type
      FROM geometry_columns 
      WHERE f_table_schema = 'public'
    `);

    for (const col of geometryColumns.rows) {
      const hasIndex = await knex.raw(`
        SELECT COUNT(*) as count
        FROM pg_indexes 
        WHERE tablename = ? AND indexdef LIKE '%gist%' AND indexdef LIKE ?
      `, [col.f_table_name, `%${col.f_geometry_column}%`]);

      if (hasIndex.rows[0].count === 0) {
        this.results.recommendations.push(
          `‚ùå Missing GIST index on ${col.f_table_name}.${col.f_geometry_column}`
        );
      }
    }
  }

  private async analyzeTableStatistics(): Promise<void> {
    console.log('üìà Analyzing table statistics...');

    const tableStatsQuery = `
      SELECT 
        schemaname,
        tablename,
        n_tup_ins as inserts,
        n_tup_upd as updates,
        n_tup_del as deletes,
        n_live_tup as live_tuples,
        n_dead_tup as dead_tuples,
        last_vacuum,
        last_autovacuum,
        last_analyze,
        last_autoanalyze,
        pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) as total_size
      FROM pg_stat_user_tables 
      WHERE schemaname = 'public'
      ORDER BY pg_total_relation_size(schemaname||'.'||tablename) DESC;
    `;

    const stats = await knex.raw(tableStatsQuery);
    this.results.tableStats = stats.rows;

    // Check for tables that need maintenance
    for (const table of stats.rows) {
      const deadTupleRatio = table.dead_tuples / (table.live_tuples + table.dead_tuples + 1);
      
      if (deadTupleRatio > 0.1) {
        this.results.recommendations.push(
          `‚ö†Ô∏è Table ${table.tablename} has ${(deadTupleRatio * 100).toFixed(1)}% dead tuples - consider VACUUM`
        );
      }

      const daysSinceAnalyze = table.last_analyze ? 
        Math.floor((Date.now() - new Date(table.last_analyze).getTime()) / (1000 * 60 * 60 * 24)) : 999;

      if (daysSinceAnalyze > 7) {
        this.results.recommendations.push(
          `üìä Table ${table.tablename} last analyzed ${daysSinceAnalyze} days ago - consider ANALYZE`
        );
      }
    }
  }

  private async analyzeSpatialQueries(): Promise<void> {
    console.log('üîç Analyzing spatial query patterns...');

    // Test common spatial query patterns
    const testQueries = [
      {
        name: 'Point-in-polygon query',
        query: `
          EXPLAIN (ANALYZE, BUFFERS) 
          SELECT count(*) FROM features 
          WHERE ST_Contains(geom, ST_SetSRID(ST_MakePoint(-74.006, 40.7128), 4326))
        `
      },
      {
        name: 'Proximity search',
        query: `
          EXPLAIN (ANALYZE, BUFFERS)
          SELECT id FROM features 
          WHERE ST_DWithin(geom::geography, ST_SetSRID(ST_MakePoint(-74.006, 40.7128), 4326)::geography, 1000)
          LIMIT 10
        `
      },
      {
        name: 'Bounding box query',
        query: `
          EXPLAIN (ANALYZE, BUFFERS)
          SELECT id FROM features 
          WHERE geom && ST_MakeEnvelope(-74.1, 40.7, -73.9, 40.8, 4326)
          LIMIT 100
        `
      }
    ];

    for (const test of testQueries) {
      try {
        const start = Date.now();
        const result = await knex.raw(test.query);
        const duration = Date.now() - start;

        const plan = result.rows.find((row: any) => row['QUERY PLAN'])?.['QUERY PLAN'];
        const executionTime = this.extractExecutionTime(plan);

        this.results.queries.push({
          query: test.name,
          avgTime: executionTime || duration,
          calls: 1,
          totalTime: executionTime || duration,
          rowsReturned: 0,
          recommendation: this.getQueryRecommendation(test.name, executionTime || duration, plan)
        });

      } catch (error) {
        console.warn(`Failed to analyze query ${test.name}:`, (error as Error).message);
      }
    }
  }

  private async checkGeometryComplexity(): Promise<void> {
    console.log('üî¢ Checking geometry complexity...');

    try {
      const complexityStats = await knex.raw(`
        SELECT 
          feature_type,
          ST_GeometryType(geom) as geom_type,
          count(*) as feature_count,
          avg(ST_NPoints(geom)) as avg_points,
          max(ST_NPoints(geom)) as max_points,
          avg(ST_Area(geom::geography)) as avg_area_sqm,
          avg(octet_length(ST_AsBinary(geom))) as avg_size_bytes
        FROM features 
        WHERE geom IS NOT NULL
        GROUP BY feature_type, ST_GeometryType(geom)
        ORDER BY avg_points DESC
      `);

      for (const stat of complexityStats.rows) {
        if (stat.max_points > 10000) {
          this.results.recommendations.push(
            `‚ö° Feature type '${stat.feature_type}' has geometries with up to ${stat.max_points} points - consider simplification`
          );
        }

        if (stat.avg_size_bytes > 100000) {
          this.results.recommendations.push(
            `üíæ Feature type '${stat.feature_type}' has large geometries (avg ${Math.round(stat.avg_size_bytes / 1024)}KB) - consider LOD strategy`
          );
        }
      }

      this.results.metrics.push({
        metric: 'Geometry Types Analyzed',
        value: complexityStats.rows.length,
        status: 'good'
      });

    } catch (error) {
      console.warn('Could not analyze geometry complexity:', (error as Error).message);
    }
  }

  private async analyzeStorageUsage(): Promise<void> {
    console.log('üíæ Analyzing storage usage...');

    const storageQuery = `
      SELECT 
        tablename,
        pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) as total_size,
        pg_size_pretty(pg_relation_size(schemaname||'.'||tablename)) as table_size,
        pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename) - pg_relation_size(schemaname||'.'||tablename)) as index_size,
        round(100.0 * (pg_total_relation_size(schemaname||'.'||tablename) - pg_relation_size(schemaname||'.'||tablename)) / pg_total_relation_size(schemaname||'.'||tablename), 1) as index_ratio
      FROM pg_stat_user_tables 
      WHERE schemaname = 'public'
      ORDER BY pg_total_relation_size(schemaname||'.'||tablename) DESC;
    `;

    const storage = await knex.raw(storageQuery);

    for (const table of storage.rows) {
      if (table.index_ratio > 80) {
        this.results.recommendations.push(
          `üì¶ Table ${table.tablename} has ${table.index_ratio}% index overhead - review index strategy`
        );
      }
    }

    this.results.metrics.push({
      metric: 'Tables Analyzed',
      value: storage.rows.length,
      status: 'good'
    });
  }

  private async benchmarkCommonOperations(): Promise<void> {
    console.log('‚è±Ô∏è Benchmarking common spatial operations...');

    const benchmarks = [
      {
        name: 'ST_Distance calculation',
        operation: `SELECT ST_Distance(
          ST_SetSRID(ST_MakePoint(-74.006, 40.7128), 4326)::geography,
          ST_SetSRID(ST_MakePoint(-73.935, 40.730), 4326)::geography
        )`
      },
      {
        name: 'ST_Contains check',
        operation: `SELECT ST_Contains(
          ST_Buffer(ST_SetSRID(ST_MakePoint(-74.006, 40.7128), 4326)::geography, 1000)::geometry,
          ST_SetSRID(ST_MakePoint(-74.005, 40.712), 4326)
        )`
      },
      {
        name: 'Geometry validation',
        operation: `SELECT ST_IsValid(ST_GeomFromText('POLYGON((0 0, 1 0, 1 1, 0 1, 0 0))', 4326))`
      }
    ];

    for (const benchmark of benchmarks) {
      const iterations = 1000;
      const start = Date.now();

      for (let i = 0; i < iterations; i++) {
        await knex.raw(benchmark.operation);
      }

      const totalTime = Date.now() - start;
      const avgTime = totalTime / iterations;

      this.results.metrics.push({
        metric: `${benchmark.name} (avg ms)`,
        value: avgTime.toFixed(3),
        status: avgTime < 1 ? 'good' : avgTime < 5 ? 'warning' : 'critical',
        recommendation: avgTime > 5 ? 'Operation is slow - check configuration' : undefined
      });
    }
  }

  private generateRecommendations(): void {
    console.log('üí° Generating optimization recommendations...');

    // Analyze results and add general recommendations
    const criticalMetrics = this.results.metrics.filter(m => m.status === 'critical');
    const warningMetrics = this.results.metrics.filter(m => m.status === 'warning');

    if (criticalMetrics.length > 0) {
      this.results.recommendations.unshift(
        `üö® ${criticalMetrics.length} critical performance issues found - immediate attention required`
      );
    }

    if (warningMetrics.length > 0) {
      this.results.recommendations.unshift(
        `‚ö†Ô∏è ${warningMetrics.length} performance warnings found - optimization recommended`
      );
    }

    // Add general PostGIS optimization recommendations
    this.results.recommendations.push(
      'üìã General Recommendations:',
      '  ‚Ä¢ Run VACUUM ANALYZE regularly on spatial tables',
      '  ‚Ä¢ Consider partitioning large spatial tables by geographic region',
      '  ‚Ä¢ Use appropriate SRID for your data (local projections for better performance)',
      '  ‚Ä¢ Implement geometry simplification for web map tiles',
      '  ‚Ä¢ Monitor query plans and adjust indexes based on actual usage patterns'
    );
  }

  private async generateReport(): Promise<void> {
    console.log('üìÑ Generating performance report...');

    const report = {
      timestamp: new Date().toISOString(),
      summary: {
        totalMetrics: this.results.metrics.length,
        criticalIssues: this.results.metrics.filter(m => m.status === 'critical').length,
        warnings: this.results.metrics.filter(m => m.status === 'warning').length,
        indexesAnalyzed: this.results.indexes.length,
        tablesAnalyzed: this.results.tableStats.length
      },
      ...this.results
    };

    const reportPath = path.join(__dirname, '../../reports');
    if (!fs.existsSync(reportPath)) {
      fs.mkdirSync(reportPath, { recursive: true });
    }

    const filename = `spatial-performance-audit-${Date.now()}.json`;
    const filepath = path.join(reportPath, filename);

    fs.writeFileSync(filepath, JSON.stringify(report, null, 2));

    // Generate human-readable summary
    this.printSummary();

    console.log(`\nüìã Full report saved to: ${filepath}`);
  }

  private printSummary(): void {
    console.log('\n' + '='.repeat(60));
    console.log('üìä SPATIAL PERFORMANCE AUDIT SUMMARY');
    console.log('='.repeat(60));

    console.log('\nüéØ Key Metrics:');
    this.results.metrics.forEach(metric => {
      const icon = metric.status === 'good' ? '‚úÖ' : metric.status === 'warning' ? '‚ö†Ô∏è' : '‚ùå';
      console.log(`  ${icon} ${metric.metric}: ${metric.value}`);
      if (metric.recommendation) {
        console.log(`     ‚Üí ${metric.recommendation}`);
      }
    });

    console.log('\nüîç Index Analysis:');
    this.results.indexes.slice(0, 5).forEach(idx => {
      console.log(`  üìä ${idx.table}.${idx.index} (${idx.type}): ${idx.scans} scans, ${idx.efficiency}% efficiency`);
    });

    console.log('\n‚è±Ô∏è Query Performance:');
    this.results.queries.forEach(query => {
      console.log(`  üîç ${query.query}: ${query.avgTime.toFixed(2)}ms avg`);
    });

    console.log('\nüí° Top Recommendations:');
    this.results.recommendations.slice(0, 10).forEach(rec => {
      console.log(`  ${rec}`);
    });

    console.log('\n' + '='.repeat(60));
  }

  // Utility methods
  private evaluateBufferSize(bufferSize: string): 'good' | 'warning' | 'critical' {
    const value = parseInt(bufferSize);
    const unit = bufferSize.replace(/[0-9]/g, '').toLowerCase();
    
    if (unit.includes('gb') && value >= 2) return 'good';
    if (unit.includes('mb') && value >= 512) return 'warning';
    return 'critical';
  }

  private evaluateWorkMem(workMem: string): 'good' | 'warning' | 'critical' {
    const value = parseInt(workMem);
    const unit = workMem.replace(/[0-9]/g, '').toLowerCase();
    
    if (unit.includes('mb') && value >= 64) return 'good';
    if (unit.includes('mb') && value >= 16) return 'warning';
    return 'critical';
  }

  private getIndexRecommendation(idx: any): string {
    if (idx.idx_scan === 0) return 'Index never used - consider dropping';
    if (idx.efficiency < 50) return 'Low efficiency - review query patterns';
    if (idx.idx_scan > 1000 && idx.efficiency > 90) return 'High-performance index';
    return 'Monitor usage patterns';
  }

  private getQueryRecommendation(_queryName: string, executionTime: number, plan?: string): string {
    if (executionTime > 1000) return 'Query is slow - optimize or add indexes';
    if (executionTime > 100) return 'Consider optimization';
    if (plan && plan.includes('Seq Scan')) return 'Sequential scan detected - check indexes';
    return 'Performance acceptable';
  }

  private extractExecutionTime(plan: string): number | null {
    if (!plan) return null;
    const match = plan.match(/Execution time: ([\d.]+) ms/);
    return match ? parseFloat(match[1]) : null;
  }
}

// CLI execution
async function main() {
  const auditor = new SpatialPerformanceAuditor();
  
  try {
    await auditor.runFullAudit();
    process.exit(0);
  } catch (error) {
    console.error('Audit failed:', error);
    process.exit(1);
  }
}

// Run if called directly
if (require.main === module) {
  main();
}

export { SpatialPerformanceAuditor };